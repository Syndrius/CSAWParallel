FUNCTION  GetJuliaNestingStruct()
    Defined: ~/.vim/bundle/julia-vim/indent/julia.vim:50
Called 2 times
Total time:   0.000399000
 Self time:   0.000260000

count     total (s)      self (s)
                                    " Auxiliary function to inspect the block structure of a line
    2                 0.000004000   let line = getline(a:lnum)
    2                 0.000004000   let s = a:0 > 0 ? a:1 : 0
    2                 0.000002000   let e = a:0 > 1 ? a:2 : -1
    2                 0.000003000   let blocks_stack = []
    2                 0.000002000   let num_closed_blocks = 0
    2                 0.000002000   while 1
    2   0.000110000   0.000021000     let fb = JuliaMatch(a:lnum, line, '\<\%(if\|else\%(if\)\?\|while\|for\|try\|catch\|finally\|\%(staged\)\?function\|macro\|begin\|mutable\s\+struct\|\%(mutable\s\+\)\@<!struct\|\%(abstract\|primitive\)\s\+type\|let\|\%(bare\)\?module\|quote\|do\)\>', s, e)
    2   0.000058000   0.000008000     let fe = JuliaMatch(a:lnum, line, '\<end\>', s, e)
                                  
    2                 0.000003000     if fb < 0 && fe < 0
                                        " No blocks found
    2                 0.000001000       break
                                      end
                                  
                                      if fb >= 0 && (fb < fe || fe < 0)
                                        " The first occurrence is an opening block keyword
                                        " Note: some keywords (elseif,else,catch,finally) are both
                                        "       closing blocks and opening new ones
                                  
                                        let i = JuliaMatch(a:lnum, line, '\<if\>', s)
                                        if i >= 0 && i == fb
                                          let s = i+1
                                          call add(blocks_stack, 'if')
                                          continue
                                        endif
                                        let i = JuliaMatch(a:lnum, line, '\<elseif\>', s)
                                        if i >= 0 && i == fb
                                          let s = i+1
                                          if len(blocks_stack) > 0 && blocks_stack[-1] == 'if'
                                            let blocks_stack[-1] = 'elseif'
                                          elseif (len(blocks_stack) > 0 && blocks_stack[-1] != 'elseif') || len(blocks_stack) == 0
                                            call add(blocks_stack, 'elseif')
                                            let num_closed_blocks += 1
                                          endif
                                          continue
                                        endif
                                        let i = JuliaMatch(a:lnum, line, '\<else\>', s)
                                        if i >= 0 && i == fb
                                          let s = i+1
                                          if len(blocks_stack) > 0 && blocks_stack[-1] =~# '\<\%(\%(else\)\=if\|catch\)\>'
                                            let blocks_stack[-1] = 'else'
                                          else
                                            call add(blocks_stack, 'else')
                                            let num_closed_blocks += 1
                                          endif
                                          continue
                                        endif
                                  
                                        let i = JuliaMatch(a:lnum, line, '\<try\>', s)
                                        if i >= 0 && i == fb
                                          let s = i+1
                                          call add(blocks_stack, 'try')
                                          continue
                                        endif
                                        let i = JuliaMatch(a:lnum, line, '\<catch\>', s)
                                        if i >= 0 && i == fb
                                          let s = i+1
                                          if len(blocks_stack) > 0 && blocks_stack[-1] =~# '\<\%(try\|finally\)\>'
                                            let blocks_stack[-1] = 'catch'
                                          else
                                            call add(blocks_stack, 'catch')
                                            let num_closed_blocks += 1
                                          endif
                                          continue
                                        endif
                                        let i = JuliaMatch(a:lnum, line, '\<finally\>', s)
                                        if i >= 0 && i == fb
                                          let s = i+1
                                          if len(blocks_stack) > 0 && blocks_stack[-1] =~# '\<\%(try\|catch\|else\)\>'
                                            let blocks_stack[-1] = 'finally'
                                          else
                                            call add(blocks_stack, 'finally')
                                            let num_closed_blocks += 1
                                          endif
                                          continue
                                        endif
                                  
                                        let i = JuliaMatch(a:lnum, line, '\<\%(bare\)\?module\>', s)
                                        if i >= 0 && i == fb
                                          let s = i+1
                                          if i == 0
                                            call add(blocks_stack, 'col1module')
                                          else
                                            call add(blocks_stack, 'other')
                                          endif
                                          continue
                                        endif
                                  
                                        let i = JuliaMatch(a:lnum, line, '\<\%(while\|for\|function\|macro\|begin\|\%(mutable\s\+\)\?struct\|\%(abstract\|primitive\)\s\+type\|let\|quote\|do\)\>', s)
                                        if i >= 0 && i == fb
                                          if match(line, '\C\<\%(mutable\|abstract\|primitive\)', i) != -1
                                            let s = i+11
                                          else
                                            let s = i+1
                                          endif
                                          call add(blocks_stack, 'other')
                                          continue
                                        endif
                                  
                                        " Note: it should be impossible to get here
                                        break
                                  
                                      else
                                        " The first occurrence is an 'end'
                                  
                                        let s = fe+1
                                        if len(blocks_stack) == 0
                                          let num_closed_blocks += 1
                                        else
                                          call remove(blocks_stack, -1)
                                        endif
                                        continue
                                  
                                      endif
                                  
                                      " Note: it should be impossible to get here
                                      break
    2                 0.000007000   endwhile
    2                 0.000007000   let num_open_blocks = len(blocks_stack) - count(blocks_stack, 'col1module')
    2                 0.000003000   return [num_open_blocks, num_closed_blocks]

FUNCTION  <SNR>71_L2U_UnsetTab()
    Defined: ~/.vim/bundle/julia-vim/autoload/LaTeXtoUnicode.vim:587
Called 1 time
Total time:   0.000191000
 Self time:   0.000191000

count     total (s)      self (s)
    1                 0.000005000   if b:l2u_cmdtab_set
    3                 0.000014000     for k in b:l2u_cmdtab_keys
    2                 0.000035000       exec 'cunmap <buffer> '.k
    3                 0.000007000     endfor
    1                 0.000007000     let b:l2u_cmdtab_set = 0
    1                 0.000001000   endif
    1                 0.000003000   if !b:l2u_tab_set
                                      return
    1                 0.000001000   endif
    1                 0.000034000   exec "setlocal completefunc=" . get(b:, "l2u_prev_completefunc", "")
    1                 0.000006000   iunmap <buffer> <Tab>
    1                 0.000020000   if empty(maparg("<Tab>", "i"))
                                      call s:L2U_ReinstateMapping(b:l2u_prev_map_tab)
    1                 0.000002000   endif
    1                 0.000010000   iunmap <buffer> <Plug>L2UTab
    1                 0.000017000   exe 'iunmap <buffer> ' . s:l2u_fallback_trigger
    1                 0.000003000   let b:l2u_tab_set = 0

FUNCTION  LastBlockIndent()
    Defined: ~/.vim/bundle/julia-vim/indent/julia.vim:320
Called 1 time
Total time:   0.000011000
 Self time:   0.000011000

count     total (s)      self (s)
    1                 0.000002000   let lnum = a:lnum
    1                 0.000001000   let ind = 0
    1                 0.000001000   while lnum > 0
    1                 0.000003000     let ind = indent(lnum)
    1                 0.000001000     if ind == 0
    1                 0.000001000       return [lnum, 0]
                                      endif
                                      if !IsInBrackets(lnum, 1)
                                        break
                                      endif
                                      let lnum = prevnonblank(lnum - 1)
                                    endwhile
                                    return [max([lnum,1]), ind]

FUNCTION  <SNR>71_L2U_UnsetAutoSub()
    Defined: ~/.vim/bundle/julia-vim/autoload/LaTeXtoUnicode.vim:692
Called 1 time
Total time:   0.000008000
 Self time:   0.000008000

count     total (s)      self (s)
    1                 0.000003000   if !b:l2u_autosub_set
    1                 0.000002000     return
                                    endif
                                  
                                    iunmap <buffer> <CR>
                                    if empty(maparg("<CR>", "i"))
                                      call s:L2U_ReinstateMapping(b:l2u_prev_map_cr)
                                    endif
                                    iunmap <buffer> <Plug>L2UAutoSub
                                    exe 'iunmap <buffer> ' . s:l2u_fallback_trigger_cr
                                    augroup L2UAutoSub
                                      autocmd! * <buffer>
                                    augroup END
                                    let b:l2u_autosub_set = 0

FUNCTION  <SNR>59_Remove_Matches()
    Defined: /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim:213
Called 59 times
Total time:   0.001049000
 Self time:   0.001049000

count     total (s)      self (s)
   59                 0.000239000   if exists('w:paren_hl_on') && w:paren_hl_on
                                      while !empty(w:matchparen_ids)
                                        silent! call remove(w:matchparen_ids, 0)->matchdelete()
                                      endwhile
                                      let w:paren_hl_on = 0
   59                 0.000049000   endif

FUNCTION  JuliaMatch()
    Defined: ~/.vim/bundle/julia-vim/indent/julia.vim:27
Called 5 times
Total time:   0.000769000
 Self time:   0.000769000

count     total (s)      self (s)
    5                 0.000006000   let s = a:st
    5                 0.000008000   let e = a:0 > 0 ? a:1 : -1
    5                 0.000005000   let basic_skip = a:0 > 1 ? a:2 : 'all'
    5                 0.000011000   let skip = basic_skip ==# 'basic' ? s:skipPatternsBasic : s:skipPatterns
    5                 0.000003000   while 1
    5                 0.000055000     let f = match(a:str, '\C' . a:regex, s)
    5                 0.000006000     if e >= 0 && f >= e
                                        return -1
    5                 0.000000000     endif
    5                 0.000004000     if f >= 0
    1                 0.000293000       let attr = synIDattr(synID(a:lnum,f+1,1),"name")
    1                 0.000286000       let attrT = synIDattr(synID(a:lnum,f+1,0),"name")
    1                 0.000023000       if attr =~# skip || attrT =~# skip
                                          let s = f+1
                                          continue
    1                 0.000001000       endif
    5                 0.000002000     endif
    5                 0.000002000     break
    5                 0.000005000   endwhile
    5                 0.000005000   return f

FUNCTION  <SNR>74_cursor_moved()
    Defined: ~/.vim/bundle/julia-vim/autoload/julia_blocks.vim:834
Called 8 times
Total time:   0.000251000
 Self time:   0.000251000

count     total (s)      self (s)
    8                 0.000069000   if b:jlblk_inwrapper && !(a:0 > 0 && a:1)
                                      return
    8                 0.000012000   endif
    8                 0.000056000   let b:jlblk_did_select = b:jlblk_doing_select
    8                 0.000063000   let b:jlblk_doing_select = 0

FUNCTION  <SNR>71_L2U_SetAutoSub()
    Defined: ~/.vim/bundle/julia-vim/autoload/LaTeXtoUnicode.vim:664
Called 1 time
Total time:   0.000032000
 Self time:   0.000032000

count     total (s)      self (s)
    1                 0.000003000   if b:l2u_autosub_set
                                      return
    1                 0.000001000   endif
                                    " g:did_insert_enter is set from an autocommand in ftdetect
    1                 0.000007000   if a:wait_insert_enter && !get(g:, "did_insert_enter", 0)
                                      return
    1                 0.000001000   endif
    1                 0.000008000   if !get(g:, "latex_to_unicode_auto", 0) || !b:l2u_enabled
    1                 0.000002000     return
                                    endif
                                    " Viable substitutions are searched at every character insertion via the
                                    " autocmd InsertCharPre. The <Enter> key does not seem to be catched in
                                    " this way though, so we use a mapping for that case.
                                  
                                    let b:l2u_prev_map_cr = s:L2U_SetFallbackMapping('<CR>', s:l2u_fallback_trigger_cr)
                                    imap <buffer> <CR> <Plug>L2UAutoSub
                                    exec 'inoremap <buffer><expr> <Plug>L2UAutoSub LaTeXtoUnicode#AutoSub("\n", "' . s:l2u_fallback_trigger_cr . '")'
                                  
                                    augroup L2UAutoSub
                                      autocmd! * <buffer>
                                      autocmd InsertCharPre <buffer> call LaTeXtoUnicode#AutoSub()
                                    augroup END
                                  
                                    let b:l2u_autosub_set = 1

FUNCTION  <SNR>71_L2U_UnsetKeymap()
    Defined: ~/.vim/bundle/julia-vim/autoload/LaTeXtoUnicode.vim:716
Called 1 time
Total time:   0.000006000
 Self time:   0.000006000

count     total (s)      self (s)
    1                 0.000003000   if !b:l2u_keymap_set
    1                 0.000001000     return
                                    endif
                                    setlocal keymap=
                                    let b:l2u_keymap_set = 0

FUNCTION  IsInBrackets()
    Defined: ~/.vim/bundle/julia-vim/indent/julia.vim:275
Called 2 times
Total time:   0.002235000
 Self time:   0.002235000

count     total (s)      self (s)
    2                 0.002191000   let stack = map(synstack(a:lnum, a:c), 'synIDattr(v:val, "name")')
    2                 0.000036000   call filter(stack, 'v:val =~# s:bracketBlocks')
    2                 0.000005000   return len(stack) > 0

FUNCTION  <SNR>71_L2U_SetFallbackMapping()
    Defined: ~/.vim/bundle/julia-vim/autoload/LaTeXtoUnicode.vim:345
Called 1 time
Total time:   0.000251000
 Self time:   0.000251000

count     total (s)      self (s)
    1                 0.000037000   let mmdict = maparg(a:s, 'i', 0, 1)
    1                 0.000010000   if empty(mmdict) || !has_key(mmdict, "rhs")
                                      exe 'inoremap <buffer> ' . a:k . ' ' . a:s
                                      return mmdict
    1                 0.000001000   endif
    1                 0.000006000   let rhs = mmdict["rhs"]
    1                 0.000031000   if rhs =~# '^<Plug>L2U'
                                      return mmdict
    1                 0.000001000   endif
    1                 0.000003000   let pre = '<buffer>'
    1                 0.000012000   let pre = pre . (mmdict["silent"] ? '<silent>' : '')
    1                 0.000006000   let pre = pre . (mmdict["expr"] ? '<expr>' : '')
    1                 0.000003000   if mmdict["noremap"]
                                      let cmd = 'inoremap '
    1                 0.000002000   else
    1                 0.000002000     let cmd = 'imap '
                                      " This is a nasty hack used to prevent infinite recursion. It's not a
                                      " general solution. Also, it doesn't work with <CR> since that stops
                                      " parsing of the <C-R>=... expression, so we need to special-case it.
                                      " Also, if the original mapping was intended to be recursive, this
                                      " will break it.
    1                 0.000004000     if a:s != "<CR>"
    1                 0.000028000       let rhs = substitute(rhs, '\c' . a:s, "\<C-R>=LaTeXtoUnicode#PutLiteral('" . a:s . "')\<CR>", 'g')
                                      else
                                        let rhs = substitute(rhs, '\c' . a:s, "\<C-R>=LaTeXtoUnicode#PutLiteralCR()\<CR>", 'g')
    1                 0.000001000     endif
                                      " Make the mapping silent even if it wasn't originally
    1                 0.000004000     if !mmdict["silent"]
    1                 0.000004000       let pre = pre . '<silent>'
    1                 0.000002000     endif
    1                 0.000002000   endif
    1                 0.000028000   exe cmd . pre . ' ' . a:k . ' ' . rhs
    1                 0.000004000   return mmdict

FUNCTION  GetJuliaIndent()
    Defined: ~/.vim/bundle/julia-vim/indent/julia.vim:336
Called 1 time
Total time:   0.005503000
 Self time:   0.000247000

count     total (s)      self (s)
                                    " Do not alter doctrings indentation
    1   0.001477000   0.000019000   if IsInDocString(v:lnum)
                                      return -1
    1                 0.000002000   endif
                                  
                                    " Find a non-blank line above the current line.
    1                 0.000004000   let lnum = prevnonblank(v:lnum - 1)
                                  
                                    " At the start of the file use zero indent.
    1                 0.000001000   if lnum == 0
                                      return 0
    1                 0.000000000   endif
                                  
    1                 0.000001000   let ind = -1
    1                 0.000001000   let st = -1
    1                 0.000001000   let lim = -1
                                  
                                    " Multiline bracketed expressions take precedence
    1                 0.000004000   let align_brackets = get(g:, "julia_indent_align_brackets", 1)
    1                 0.000002000   let align_funcargs = get(g:, "julia_indent_align_funcargs", 0)
    1                 0.000004000   let c = len(getline(lnum)) + 1
    1   0.001738000   0.000011000   while IsInBrackets(lnum, c)
                                      let [first_open_bracket, last_open_bracket, last_closed_bracket, infuncargs] = GetJuliaNestingBrackets(lnum, c)
                                  
                                      " First scenario: the previous line has a hanging open bracket:
                                      " set the indentation to match the opening bracket (plus an extra space)
                                      " unless we're in a function arguments list or alignment is disabled, in
                                      " which case we just add an extra indent
                                      if last_open_bracket != -1
                                        if (!infuncargs && align_brackets) || (infuncargs && align_funcargs)
                                          let st = last_open_bracket
                                          let ind = virtcol([lnum, st + 1])
                                        else
                                          let ind = indent(lnum) + shiftwidth()
                                        endif
                                  
                                      " Second scenario: some multiline bracketed expression was closed in the
                                      " previous line. But since we know we are still in a bracketed expression,
                                      " we need to find the line where the bracket was opened
                                      elseif last_closed_bracket != -1
                                        call JumpToMatch(lnum, last_closed_bracket)
                                        if line(".") == lnum
                                          " something wrong here, give up
                                          let ind = indent(lnum)
                                        else
                                          let lnum = line(".")
                                          let c = col(".") - 1
                                          if c == 0
                                            " uhm, give up
                                            let ind = 0
                                          else
                                            " we skipped a bracket set, keep searching for an opening bracket
                                            let lim = c
                                            continue
                                          endif
                                        endif
                                  
                                      " Third scenario: nothing special: keep the indentation
                                      else
                                        let ind = indent(lnum)
                                      endif
                                  
                                      " Does the current line start with a closing bracket? Then depending on
                                      " the situation we align it with the opening one, or we let the rest of
                                      " the code figure it out (the case in which we're closing a function
                                      " argument list is special-cased)
                                      if JuliaMatch(v:lnum, getline(v:lnum), '[])}]', indent(v:lnum)) == indent(v:lnum) && ind > 0
                                        if !align_brackets && !align_funcargs
                                          call JumpToMatch(v:lnum, indent(v:lnum))
                                          return indent(line("."))
                                        elseif (align_brackets && getline(v:lnum)[indent(v:lnum)] != ')') || align_funcargs
                                          return ind - 1
                                        else " must be a ')' and align_brackets==1 and align_funcargs==0
                                          call JumpToMatch(v:lnum, indent(v:lnum))
                                          if IsFunctionArgPar(line("."), col("."))
                                            let ind = -1
                                          else
                                            return ind - 1
                                          endif
                                        endif
                                      endif
                                  
                                      break
    1                 0.000002000   endwhile
                                  
    1                 0.000001000   if ind == -1
                                      " We are not in a multiline bracketed expression. Thus we look for a
                                      " previous line to use as a reference
    1   0.000021000   0.000010000     let [lnum,ind] = LastBlockIndent(lnum)
    1                 0.000004000     let c = len(getline(lnum)) + 1
    1   0.000511000   0.000003000     if IsInBrackets(lnum, c)
                                        let [first_open_bracket, last_open_bracket, last_closed_bracket, infuncargs] = GetJuliaNestingBrackets(lnum, c)
                                        let lim = first_open_bracket
    1                 0.000001000     endif
    1                 0.000001000   end
                                  
                                    " Analyse the reference line
    1   0.000236000   0.000011000   let [num_open_blocks, num_closed_blocks] = GetJuliaNestingStruct(lnum, st, lim)
                                    " Increase indentation for each newly opened block in the reference line
    1                 0.000004000   let ind += shiftwidth() * num_open_blocks
                                  
                                    " Analyse the current line
    1   0.000178000   0.000004000   let [num_open_blocks, num_closed_blocks] = GetJuliaNestingStruct(v:lnum)
                                    " Decrease indentation for each closed block in the current line
    1                 0.000002000   let ind -= shiftwidth() * num_closed_blocks
                                  
                                    " Additional special case: multiline import/using/export/public statements
                                  
    1                 0.000002000   let prevline = getline(lnum)
                                    " Are we in a multiline import/using/export/public statement, right below the
                                    " opening line?
    1   0.000110000   0.000007000   if IsInContinuationImportLine(v:lnum) && !IsInContinuationImportLine(lnum)
                                      if get(g:, 'julia_indent_align_import', 1)
                                        " if the opening line has a colon followed by non-comments, use it as
                                        " reference point
                                        let cind = JuliaMatch(lnum, prevline, ':', indent(lnum), lim)
                                        if cind >= 0
                                          let nonwhiteind = JuliaMatch(lnum, prevline, '\S', cind+1, -1, 'basic')
                                          if nonwhiteind >= 0
                                            " return match(prevline, '\S', cind+1) " a bit overkill...
                                            return cind + 2
                                          endif
                                        else
                                          " if the opening line is not a naked import/using/export/public statement, use
                                          " it as reference
                                          let iind = JuliaMatch(lnum, prevline, '\<import\|using\|export\|public\>', indent(lnum), lim)
                                          if iind >= 0
                                            " assuming whitespace after using... so no `using(XYZ)` please!
                                            let nonwhiteind = JuliaMatch(lnum, prevline, '\S', iind+6, -1, 'basic')
                                            if nonwhiteind >= 0
                                              return match(prevline, '\S', iind+6)
                                            endif
                                          endif
                                        endif
                                      endif
                                      let ind += shiftwidth()
                                  
                                    " Or did we just close a multiline import/using/export/public statement?
    1   0.001057000   0.000007000   elseif !IsInContinuationImportLine(v:lnum) && IsInContinuationImportLine(lnum)
                                      " find the starting line of the statement
                                      let ilnum = 0
                                      for iln in range(lnum-1, 1, -1)
                                        if !IsInContinuationImportLine(iln)
                                          let ilnum = iln
                                          break
                                        endif
                                      endfor
                                      if ilnum == 0
                                        " something went horribly wrong, give up
                                        let ind = indent(lnum)
                                      endif
                                      let ind = indent(ilnum)
    1                 0.000000000   endif
                                  
    1                 0.000001000   return ind

FUNCTION  LaTeXtoUnicode#Init()
    Defined: ~/.vim/bundle/julia-vim/autoload/LaTeXtoUnicode.vim:725
Called 1 time
Total time:   0.001254000
 Self time:   0.000287000

count     total (s)      self (s)
    1                 0.000011000   let wait_insert_enter = a:0 > 0 ? a:1 : 1
                                  
    1                 0.000005000   if !wait_insert_enter
    1                 0.000005000     augroup L2UInit
    1                 0.000111000       autocmd!
    1                 0.000003000     augroup END
    1                 0.000002000   endif
                                  
    1   0.000217000   0.000026000   call s:L2U_UnsetTab()
    1   0.000033000   0.000025000   call s:L2U_UnsetAutoSub()
    1   0.000027000   0.000021000   call s:L2U_UnsetKeymap()
                                  
    1   0.000736000   0.000022000   call s:L2U_SetTab(wait_insert_enter)
    1   0.000062000   0.000030000   call s:L2U_SetAutoSub(wait_insert_enter)
    1   0.000030000   0.000014000   call s:L2U_SetKeymap()
    1                 0.000002000   return ''

FUNCTION  julia_blocks#select_reset()
    Defined: ~/.vim/bundle/julia-vim/autoload/julia_blocks.vim:827
Called 2 times
Total time:   0.000053000
 Self time:   0.000053000

count     total (s)      self (s)
    2                 0.000023000   let b:jlblk_did_select = 0
    2                 0.000008000   let b:jlblk_doing_select = 0
    2                 0.000006000   let b:jlblk_inwrapper = 0
    2                 0.000008000   let b:jlblk_last_mode = ""

FUNCTION  <SNR>59_Highlight_Matching_Pair()
    Defined: /Applications/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim:47
Called 59 times
Total time:   0.007704000
 Self time:   0.006655000

count     total (s)      self (s)
   59                 0.000520000   if !exists("w:matchparen_ids")
                                      let w:matchparen_ids = []
   59                 0.000078000   endif
                                    " Remove any previous match.
   59   0.001406000   0.000357000   call s:Remove_Matches()
                                  
                                    " Avoid that we remove the popup menu.
                                    " Return when there are no colors (looks like the cursor jumps).
   59                 0.000368000   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                      return
   59                 0.000036000   endif
                                  
                                    " Get the character under the cursor and check if it's in 'matchpairs'.
   59                 0.000382000   let c_lnum = line('.')
   59                 0.000205000   let c_col = col('.')
   59                 0.000111000   let before = 0
                                  
   59                 0.000365000   let text = getline(c_lnum)
   59                 0.000478000   let c_before = text->strpart(0, c_col - 1)->slice(-1)
   59                 0.000260000   let c = text->strpart(c_col - 1)->slice(0, 1)
   59                 0.001179000   let plist = split(&matchpairs, '.\zs[:,]')
   59                 0.000268000   let i = index(plist, c)
   59                 0.000088000   if i < 0
                                      " not found, in Insert mode try character before the cursor
   59                 0.000295000     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   48                 0.000124000       let before = strlen(c_before)
   48                 0.000057000       let c = c_before
   48                 0.000098000       let i = index(plist, c)
   59                 0.000050000     endif
   59                 0.000075000     if i < 0
                                        " not found, nothing to do
   59                 0.000081000       return
                                      endif
                                    endif
                                  
                                    " Figure out the arguments for searchpairpos().
                                    if i % 2 == 0
                                      let s_flags = 'nW'
                                      let c2 = plist[i + 1]
                                    else
                                      let s_flags = 'nbW'
                                      let c2 = c
                                      let c = plist[i - 1]
                                    endif
                                    if c == '['
                                      let c = '\['
                                      let c2 = '\]'
                                    endif
                                  
                                    " Find the match.  When it was just before the cursor move it there for a
                                    " moment.
                                    if before > 0
                                      let has_getcurpos = exists("*getcurpos")
                                      if has_getcurpos
                                        " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                        let save_cursor = getcurpos()
                                      else
                                        let save_cursor = winsaveview()
                                      endif
                                      call cursor(c_lnum, c_col - before)
                                    endif
                                  
                                    if !has("syntax") || !exists("g:syntax_on")
                                      let s_skip = "0"
                                    else
                                      " Build an expression that detects whether the current cursor position is
                                      " in certain syntax types (string, comment, etc.), for use as
                                      " searchpairpos()'s skip argument.
                                      " We match "escape" for special items, such as lispEscapeSpecial, and
                                      " match "symbol" for lispBarSymbol.
                                      let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                      " If executing the expression determines that the cursor is currently in
                                      " one of the syntax types, then we want searchpairpos() to find the pair
                                      " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                      " outside of the syntax types and s_skip should keep its value so we skip
                                      " any matching pair inside the syntax types.
                                      " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                      try
                                        execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                      catch /^Vim\%((\a\+)\)\=:E363/
                                        " We won't find anything, so skip searching, should keep Vim responsive.
                                        return
                                      endtry
                                    endif
                                  
                                    " Limit the search to lines visible in the window.
                                    let stoplinebottom = line('w$')
                                    let stoplinetop = line('w0')
                                    if i % 2 == 0
                                      let stopline = stoplinebottom
                                    else
                                      let stopline = stoplinetop
                                    endif
                                  
                                    " Limit the search time to 300 msec to avoid a hang on very long lines.
                                    " This fails when a timeout is not supported.
                                    if mode() == 'i' || mode() == 'R'
                                      let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                                    else
                                      let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                                    endif
                                    try
                                      let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                                    catch /E118/
                                      " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                      " a long time on closed folds and long lines.
                                      " The "viewable" variables give a range in which we can scroll while
                                      " keeping the cursor at the same position.
                                      " adjustedScrolloff accounts for very large numbers of scrolloff.
                                      let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                      let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                      let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                      " one of these stoplines will be adjusted below, but the current values are
                                      " minimal boundaries within the current window
                                      if i % 2 == 0
                                        if has("byte_offset") && has("syntax_items") && &smc > 0
                                  	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                                  	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                        else
                                  	let stopline = min([bottom_viewable, c_lnum + 100])
                                        endif
                                        let stoplinebottom = stopline
                                      else
                                        if has("byte_offset") && has("syntax_items") && &smc > 0
                                  	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                                  	let stopline = max([top_viewable, byte2line(stopbyte)])
                                        else
                                  	let stopline = max([top_viewable, c_lnum - 100])
                                        endif
                                        let stoplinetop = stopline
                                      endif
                                      let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                                    endtry
                                  
                                    if before > 0
                                      if has_getcurpos
                                        call setpos('.', save_cursor)
                                      else
                                        call winrestview(save_cursor)
                                      endif
                                    endif
                                  
                                    " If a match is found setup match highlighting.
                                    if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                      if s:has_matchaddpos
                                        if !g:matchparen_disable_cursor_hl
                                          call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                        else
                                          call add(w:matchparen_ids, matchaddpos('MatchParen', [[m_lnum, m_col]], 10))
                                        endif
                                      else
                                        if !g:matchparen_disable_cursor_hl
                                          exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                        else
                                          exe '3match MatchParen /\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                        endif
                                        call add(w:matchparen_ids, 3)
                                      endif
                                      let w:paren_hl_on = 1
                                    endif

FUNCTION  <SNR>71_L2U_SetKeymap()
    Defined: ~/.vim/bundle/julia-vim/autoload/LaTeXtoUnicode.vim:709
Called 1 time
Total time:   0.000016000
 Self time:   0.000016000

count     total (s)      self (s)
    1                 0.000009000   if !b:l2u_keymap_set && get(g:, "latex_to_unicode_keymap", 0) && b:l2u_enabled
                                      setlocal keymap=latex2unicode
                                      let b:l2u_keymap_set = 1
    1                 0.000001000   endif

FUNCTION  IsInContinuationImportLine()
    Defined: ~/.vim/bundle/julia-vim/indent/julia.vim:287
Called 3 times
Total time:   0.001153000
 Self time:   0.000523000

count     total (s)      self (s)
    3                 0.000481000   let stack = map(synstack(a:lnum, 1), 'synIDattr(v:val, "name")')
    3                 0.000023000   call filter(stack, 'v:val =~# "\\<juliaImportLine\\>"')
    3                 0.000004000   if len(stack) == 0
    2                 0.000002000     return 0
    1                 0.000001000   endif
    1   0.000637000   0.000007000   return JuliaMatch(a:lnum, getline(a:lnum), '\<\%(import\|using\|export\|public\)\>', indent(a:lnum)) == -1

FUNCTION  IsInDocString()
    Defined: ~/.vim/bundle/julia-vim/indent/julia.vim:281
Called 1 time
Total time:   0.001458000
 Self time:   0.001458000

count     total (s)      self (s)
    1                 0.001434000   let stack = map(synstack(a:lnum, 1), 'synIDattr(v:val, "name")')
    1                 0.000018000   call filter(stack, 'v:val =~# "\\<juliaDocString\\(Delim\\|M\\\(Raw\\)\\?\\)\\?\\>"')
    1                 0.000003000   return len(stack) > 0

FUNCTION  <SNR>71_L2U_SetTab()
    Defined: ~/.vim/bundle/julia-vim/autoload/LaTeXtoUnicode.vim:548
Called 1 time
Total time:   0.000714000
 Self time:   0.000463000

count     total (s)      self (s)
    1                 0.000019000   let opt_do_cmdtab = index(["on", "command", "cmd"], get(g:, "latex_to_unicode_tab", "on")) != -1
    1                 0.000011000   let opt_do_instab = index(["on", "insert", "ins"], get(g:, "latex_to_unicode_tab", "on")) != -1
    1                 0.000007000   if !b:l2u_cmdtab_set && opt_do_cmdtab && b:l2u_enabled
    1                 0.000014000     let b:l2u_cmdtab_keys = get(g:, "latex_to_unicode_cmd_mapping", ['<Tab>','<S-Tab>'])
    1                 0.000009000     if type(b:l2u_cmdtab_keys) != type([]) " avoid using v:t_list for backward compatibility
                                        let b:l2u_cmdtab_keys = [b:l2u_cmdtab_keys]
    1                 0.000001000     endif
    3                 0.000011000     for k in b:l2u_cmdtab_keys
    2                 0.000053000       exec 'let trigger = char2nr("'.(k[0] == '<' ? '\' : '').k.'")'
    2                 0.000114000       exec 'cnoremap <buffer><expr> '.k.' LaTeXtoUnicode#CmdTab('.trigger.')'
    3                 0.000008000     endfor
    1                 0.000005000     let b:l2u_cmdtab_set = 1
    1                 0.000002000   endif
    1                 0.000004000   if b:l2u_tab_set
                                      return
    1                 0.000001000   endif
                                    " g:did_insert_enter is set from an autocommand in ftdetect
    1                 0.000018000   if a:wait_insert_enter && !get(g:, "did_insert_enter", 0)
                                      return
    1                 0.000001000   endif
    1                 0.000005000   if !opt_do_instab || !b:l2u_enabled
                                      return
    1                 0.000001000   endif
                                  
                                    " Backup the previous completefunc (the check is probably not really needed)
    1                 0.000010000   if get(b:, "l2u_prev_completefunc", "") != "LaTeXtoUnicode#completefunc"
    1                 0.000007000     let b:l2u_prev_completefunc = &completefunc
    1                 0.000002000   endif
    1                 0.000012000   setlocal completefunc=LaTeXtoUnicode#completefunc
                                  
    1   0.000328000   0.000077000   let b:l2u_prev_map_tab = s:L2U_SetFallbackMapping('<Tab>', s:l2u_fallback_trigger)
    1                 0.000009000   imap <buffer> <Tab> <Plug>L2UTab
    1                 0.000012000   inoremap <buffer><expr> <Plug>L2UTab LaTeXtoUnicode#Tab()
                                  
    1                 0.000004000   let b:l2u_tab_set = 1

FUNCTIONS SORTED ON TOTAL TIME
count     total (s)      self (s)  function
   59   0.007704000   0.006655000  <SNR>59_Highlight_Matching_Pair()
    1   0.005503000   0.000247000  GetJuliaIndent()
    2   0.002235000                IsInBrackets()
    1   0.001458000                IsInDocString()
    1   0.001254000   0.000287000  LaTeXtoUnicode#Init()
    3   0.001153000   0.000523000  IsInContinuationImportLine()
   59   0.001049000                <SNR>59_Remove_Matches()
    5   0.000769000                JuliaMatch()
    1   0.000714000   0.000463000  <SNR>71_L2U_SetTab()
    2   0.000399000   0.000260000  GetJuliaNestingStruct()
    1   0.000251000                <SNR>71_L2U_SetFallbackMapping()
    8   0.000251000                <SNR>74_cursor_moved()
    1   0.000191000                <SNR>71_L2U_UnsetTab()
    2   0.000053000                julia_blocks#select_reset()
    1   0.000032000                <SNR>71_L2U_SetAutoSub()
    1   0.000016000                <SNR>71_L2U_SetKeymap()
    1   0.000011000                LastBlockIndent()
    1   0.000008000                <SNR>71_L2U_UnsetAutoSub()
    1   0.000006000                <SNR>71_L2U_UnsetKeymap()

FUNCTIONS SORTED ON SELF TIME
count     total (s)      self (s)  function
   59   0.007704000   0.006655000  <SNR>59_Highlight_Matching_Pair()
    2                 0.002235000  IsInBrackets()
    1                 0.001458000  IsInDocString()
   59                 0.001049000  <SNR>59_Remove_Matches()
    5                 0.000769000  JuliaMatch()
    3   0.001153000   0.000523000  IsInContinuationImportLine()
    1   0.000714000   0.000463000  <SNR>71_L2U_SetTab()
    1   0.001254000   0.000287000  LaTeXtoUnicode#Init()
    2   0.000399000   0.000260000  GetJuliaNestingStruct()
    1                 0.000251000  <SNR>71_L2U_SetFallbackMapping()
    8                 0.000251000  <SNR>74_cursor_moved()
    1   0.005503000   0.000247000  GetJuliaIndent()
    1                 0.000191000  <SNR>71_L2U_UnsetTab()
    2                 0.000053000  julia_blocks#select_reset()
    1                 0.000032000  <SNR>71_L2U_SetAutoSub()
    1                 0.000016000  <SNR>71_L2U_SetKeymap()
    1                 0.000011000  LastBlockIndent()
    1                 0.000008000  <SNR>71_L2U_UnsetAutoSub()
    1                 0.000006000  <SNR>71_L2U_UnsetKeymap()

